DFS 

def build_tree():
    n = int(input("Enter number of nodes: "))
    tree = {i: [] for i in range(1, n+1)}

    print("Enter edges (parent child), one per line:")
    for _ in range(n-1):
        parent, child = map(int, input().split())
        tree[parent].append(child)
    return tree

def dfs_tree_iterative(tree, start):
    visited = set()
    stack = [start]

    while stack:
        node = stack.pop()
        if node not in visited:
            print(node)  # Process node
            visited.add(node)
            for child in reversed(tree.get(node, [])):
                if child not in visited:
                    stack.append(child)

tree = build_tree()
start_node = int(input("Enter start node: "))
dfs_tree_iterative(tree, start_node)

def build_tree():
    n = int(input("Enter number of nodes: "))
    tree = {i: [] for i in range(1, n+1)}

    print("Enter edges (parent child), one per line:")
    for _ in range(n-1):
        parent, child = map(int, input().split())
        tree[parent].append(child)
    return tree

def dfs_tree_iterative(tree, start):
    visited = set()
    stack = [start]

    while stack:
        node = stack.pop()
        if node not in visited:
            print(node)  # Process node
            visited.add(node)
            for child in reversed(tree.get(node, [])):
                if child not in visited:
                    stack.append(child)

tree = build_tree()
start_node = int(input("Enter start node: "))
dfs_tree_iterative(tree, start_node)


--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


BFS

from collections import deque

def build_tree():
    n = int(input("Enter number of nodes: "))
    tree = {i: [] for i in range(1, n+1)}

    print("Enter edges (parent child), one per line:")
    for _ in range(n-1):
        parent, child = map(int, input().split())
        tree[parent].append(child)
    return tree

def bfs_tree(tree, start):
    visited = set()
    queue = deque([start])

    while queue:
        node = queue.popleft()
        if node not in visited:
            print(node)  # Process node
            visited.add(node)
            for child in tree.get(node, []):
                if child not in visited:
                    queue.append(child)

tree = build_tree()
start_node = int(input("Enter start node: "))
bfs_tree(tree, start_node)

