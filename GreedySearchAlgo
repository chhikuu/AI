



KRUSKALS ALGORITHM CODE :

#include <iostream>
using namespace std;

const int inf = 999999;
int a, b, u, v, n = 5, ne = 1, mincost = 0;
int cost[5][5] = {
    {0, 10, 0, 0, 20},   // a
    {10, 0, 35, 25, 0},  // b
    {0, 35, 0, 40, 0},   // c
    {0, 25, 40, 0, 50},  // d
    {20, 0, 0, 50, 0}    // e
};
int p[5] = {0};

// Find function
int applyfind(int i) {
    while (p[i] != 0)
        i = p[i];
    return i;
}

// Union function
int applyunion(int i, int j) {
    if (i != j) {
        p[j] = i;
        return 1;
    }
    return 0;
}

int main() {
    
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (cost[i][j] == 0)
                cost[i][j] = inf;
        }
    }

    cout << "Minimum Cost Spanning Tree (Kruskal):\n";
    while (ne < n) {
        int min_val = inf;
        
        // Find minimum edge
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (cost[i][j] < min_val) {
                    min_val = cost[i][j];
                    a = u = i;
                    b = v = j;
                }
            }
        }

        u = applyfind(u);
        v = applyfind(v);

        // If no cycle, accept edge
        if (applyunion(u, v)) {
            cout << char(a + 'a') << " -> " << char(b + 'a') << " = " << min_val << "\n";
            mincost += min_val;
            ne++;
        }

        // Mark edge as visited
        cost[a][b] = cost[b][a] = inf;
    }

    cout << "Minimum cost = " << mincost << endl;
    return 0;
}









PRIMS ALGORITHM CODE :

#include <iostream>
#include <climits>

using namespace std;

int minKey(int key[], bool mstSet[], int n) {
    int min = INT_MAX;
    int min_index = -1;
    int i = 0;
    while (i < n) {
        if (!mstSet[i] && key[i] < min) {
            min = key[i];
            min_index = i;
        }
        i++;
    }
    return min_index;
}

void primMST(int graph[][5], int n) {
    int key[5];
    bool mstSet[5];
    int parent[5];

    int i = 0;
    while (i < n) {
        key[i] = INT_MAX;
        mstSet[i] = false;
        i++;
    }

    key[0] = 0;
    parent[0] = -1;

    int count = 0;
    while (count < n - 1) {
        int u = minKey(key, mstSet, n);
        mstSet[u] = true;

        int v = 0;
        while (v < n) {
            if (graph[u][v] != 0 && !mstSet[v] && graph[u][v] < key[v]) {
                key[v] = graph[u][v];
                parent[v] = u;
            }
            v++;
        }
        count++;
    }

    int min_cost = 0;
    cout << "Edge \tWeight\n";
    int j = 1;
    while (j < n) {
        cout << parent[j] << " - " << j << "\t" << graph[j][parent[j]] << "\n";
        min_cost += graph[j][parent[j]];
        j++;
    }
    cout << "Minimum cost of MST: " << min_cost << "\n";
}

int main() {
    int graph[5][5] = {
        {0, 10, 0, 0, 20},
        {10, 0, 35, 25, 0},
        {0, 35, 0, 40, 0},
        {0, 25, 40, 0, 50},
        {20, 0, 0, 50, 0}
    };

    primMST(graph, 5);

    return 0;
}









SELECTION SORT CODE :

#include <iostream>
using namespace std;

void selectionSort(int arr[], int n) {
    int i = 0;
    while (i < n - 1) {
        int min_idx = i;
        int j = i + 1;
        while (j < n) {
            if (arr[j] < arr[min_idx]) {
                min_idx = j;
            }
            j++;
        }
        // Swap arr[i] and arr[min_idx]
        int temp = arr[i];
        arr[i] = arr[min_idx];
        arr[min_idx] = temp;

        i++;
    }
}

int main() {
    int arr[] = {64, 25, 12, 22, 11};
    int n = sizeof(arr) / sizeof(arr[0]);

    selectionSort(arr, n);

    cout << "Sorted array: ";
    int k = 0;
    while (k < n) {
        cout << arr[k] << " ";
        k++;
    }
    cout << endl;

    return 0;
}







DIJKSTRA'S ALGORITHM CODE :

#include <iostream>
#include <climits>
using namespace std;

int minDistance(int dist[], bool sptSet[], int n) {
    int min = INT_MAX;
    int min_index = -1;
    int i = 0;
    while (i < n) {
        if (!sptSet[i] && dist[i] <= min) {
            min = dist[i];
            min_index = i;
        }
        i++;
    }
    return min_index;
}

void dijkstra(int graph[][5], int src, int n) {
    int dist[5];
    bool sptSet[5];

    int i = 0;
    while (i < n) {
        dist[i] = INT_MAX;
        sptSet[i] = false;
        i++;
    }

    dist[src] = 0;

    int count = 0;
    while (count < n - 1) {
        int u = minDistance(dist, sptSet, n);
        sptSet[u] = true;

        int v = 0;
        while (v < n) {
            if (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX 
                && dist[u] + graph[u][v] < dist[v]) {
                dist[v] = dist[u] + graph[u][v];
            }
            v++;
        }
        count++;
    }

    cout << "Vertex \t Distance from Source\n";
    int j = 0;
    while (j < n) {
        cout << j << " \t " << dist[j] << "\n";
        j++;
    }
}

int main() {
    int graph[5][5] = {
        {0, 10, 0, 0, 20},
        {10, 0, 35, 25, 0},
        {0, 35, 0, 40, 0},
        {0, 25, 40, 0, 50},
        {20, 0, 0, 50, 0}
    };

    dijkstra(graph, 0, 5);

    return 0;
}








JOB SCHEDULING ALGORITHM :

#include <iostream>
#include <algorithm>
using namespace std;

struct Job {
    int id;
    int deadline;
    int profit;
};

// Comparator to sort jobs by decreasing profit
bool compare(Job a, Job b) {
    return (a.profit > b.profit);
}

void jobScheduling(Job jobs[], int n) {
    // Sort jobs by profit
    sort(jobs, jobs + n, compare);

    int result[n]; // To store result (sequence of jobs)
    bool slot[n];  // To keep track of free time slots

    int i = 0;
    while (i < n) {
        slot[i] = false;
        i++;
    }

    int count = 0, totalProfit = 0;
    i = 0;
    while (i < n) {
        // Find a free slot for this job (starting from its deadline - 1)
        int j = min(n, jobs[i].deadline) - 1;
        while (j >= 0 && slot[j]) {
            j--;
        }

        // If free slot found, assign job
        if (j >= 0) {
            slot[j] = true;
            result[j] = i;
            count++;
            totalProfit += jobs[i].profit;
        }
        i++;
    }

    cout << "Number of jobs done: " << count << "\n";
    cout << "Scheduled jobs: ";
    i = 0;
    while (i < n) {
        if (slot[i]) {
            cout << jobs[result[i]].id << " ";
        }
        i++;
    }
    cout << "\nTotal Profit: " << totalProfit << "\n";
}

int main() {
    Job jobs[] = {{1, 2, 100}, {2, 1, 19}, {3, 2, 27}, {4, 1, 25}, {5, 3, 15}};
    int n = sizeof(jobs) / sizeof(jobs[0]);

    jobScheduling(jobs, n);

    return 0;
}


